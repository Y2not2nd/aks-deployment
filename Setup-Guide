📦 Project Folder Structure
All project files, configs, and scripts can be found here:
👉 GitHub Repo - https://github.com/Y2not2nd/aks-deployment

pgsql
Copy
Edit
aks-k8s-project/
├── .gitignore
├── argocd-app.yaml
├── README.md
├── terraform/
│   ├── main.tf
│   ├── variables.tf
│   ├── outputs.tf
│   └── modules/
│       └── aks/
│           ├── main.tf
│           ├── variables.tf
│           └── outputs.tf
├── static-web/
│   ├── Chart.yaml
│   ├── values.yaml
│   └── templates/
│       ├── deployment.yaml
│       ├── service.yaml
│       └── serviceaccount.yaml
├── website/
│   ├── index.html
│   ├── Dockerfile
├── vault-policies/
│   ├── static-web-policy.hcl
│   └── create-policy.sh
└── vault-init.json (⚠ should NOT be committed)
✅ IMPORTANT: Add .gitignore at the root before any commits:

csharp
Copy
Edit
.terraform/
*.tfstate
*.tfstate.backup
*.tfvars
vault-init.json
This prevents accidental commits of large binaries or sensitive files.

🌟 Project Overview
This guide walks you through setting up an end-to-end DevOps pipeline using:

Terraform (infra as code)

Azure AKS (Kubernetes)

Docker (containerization)

Helm (app deployment)

Vault (secret management)

ArgoCD (GitOps delivery)

Prometheus + Grafana (monitoring)

Azure Monitor (cloud observability)

Snyk (security scanning)

✅ Where to run commands: Specific folders + terminals will be indicated.
✅ Before starting: Install Docker, Terraform, Azure CLI, Helm, kubectl, Git, VS Code (with Terraform, Kubernetes, Azure extensions).

🏗 Step 1: Provision Infrastructure with Terraform
Why: Automate Azure resource creation.

📁 Folder: terraform/

bash
Copy
Edit
terraform init
terraform plan -var="resource_group=aks-rg" -var="location=uksouth" -var="cluster_name=myaks" -var="dns_prefix=myaksdns" -var="node_count=2"
terraform apply -auto-approve -var="resource_group=aks-rg" -var="location=uksouth" -var="cluster_name=myaks" -var="dns_prefix=myaksdns" -var="node_count=2"
az aks get-credentials --resource-group aks-rg --name myaks --overwrite-cli
kubectl get nodes
⚠ Fix: Do not commit .terraform/ — clean with Git if needed.

🐳 Step 2: Build and Test Docker Image
Why: Package the app into a portable container.

📁 Folder: website/

bash
Copy
Edit
docker build -t static-web:v1 .
docker run -d -p 8080:8080 static-web:v1
🔗 Visit: http://localhost:8080

⚠ Fix: Use non-root port (8080) for security.

🚀 Step 3: Push Image to Azure Container Registry (ACR)
Why: Store images in the cloud for Kubernetes.

📁 Folder: aks-k8s-project/

bash
Copy
Edit
az acr create -n myacrname -g aks-rg --sku Basic
az acr login -n myacrname
docker tag static-web:v1 myacrname.azurecr.io/static-web:v1
docker push myacrname.azurecr.io/static-web:v1
✅ Check: Azure Portal → ACR → Repositories.

📦 Step 4: Deploy App to AKS with Helm
Why: Simplify Kubernetes deployments.

📁 Folder: static-web/

bash
Copy
Edit
helm create static-web
# Update values.yaml:
# image.repository → myacrname.azurecr.io/static-web:v1
# service.port → 80, containerPort → 8080
helm upgrade --install static-web ./static-web --namespace default
kubectl get svc static-web
🔗 Visit: http://<EXTERNAL-IP>

⚠ Fix: Ensure readiness/liveness probes + resource limits.

🔐 Step 5: Integrate Vault for Secret Management
Why: Securely manage secrets (tokens, passwords, keys).

📁 Folder: aks-k8s-project/

bash
Copy
Edit
helm repo add hashicorp https://helm.releases.hashicorp.com
helm install vault hashicorp/vault --set server.ha.enabled=true --set server.ha.raft.enabled=true --set server.dev.enabled=false
kubectl exec -it vault-0 -- vault operator init -key-shares=1 -key-threshold=1 -format=json > vault-init.json
kubectl exec -it vault-0 -- vault operator unseal <UNSEAL_KEY>
kubectl exec -it vault-0 -- vault login <ROOT_TOKEN>
./vault-policies/create-policy.sh
kubectl exec -it vault-0 -- vault status
⚠ Fix: Avoid Windows file path issues — use heredoc where needed.

🌊 Step 6: Set Up ArgoCD for GitOps
Why: Keep Kubernetes in sync with Git.

📁 Folder: aks-k8s-project/

bash
Copy
Edit
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
kubectl port-forward svc/argocd-server -n argocd 8080:443
🔗 Login: https://localhost:8080 (admin password)

bash
Copy
Edit
kubectl apply -n argocd -f argocd-app.yaml
✅ Watch auto-sync + deployments.

📊 Step 7: Set Up Monitoring
Why: Gain insights into cluster health + performance.

📁 Folder: aks-k8s-project/

bash
Copy
Edit
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm install kube-prometheus-stack prometheus-community/kube-prometheus-stack --namespace monitoring --create-namespace
kubectl port-forward svc/kube-prometheus-stack-grafana -n monitoring 3000:80
🔗 Grafana: http://localhost:3000 (get password from secret)

bash
Copy
Edit
az aks enable-addons --addons monitoring --name myaks --resource-group aks-rg
✅ Check AKS Insights in Azure Portal.

🔍 Step 8: Scan Docker Image with Snyk
Why: Find + fix vulnerabilities.

📁 Folder: aks-k8s-project/

bash
Copy
Edit
npm install -g snyk
snyk auth
snyk test --docker static-web:v1
✅ Review + apply fixes.

🛠 Final Git Cleanup (If Needed)
✅ Add .gitignore early.
✅ To clean history if large/sensitive files were committed:

bash
Copy
Edit
git filter-repo --force --path .terraform --invert-paths
java -jar bfg.jar --delete-files vault-init.json --no-blob-protection .
java -jar bfg.jar --strip-blobs-bigger-than 100M --no-blob-protection .
git reflog expire --expire=now --all
git gc --prune=now --aggressive
git push --force --set-upstream origin main
✅ Rotate any leaked Vault tokens.

🚀 Final Achievements
✅ Cloud infrastructure with Terraform
✅ Dockerized app deployed with Helm
✅ Secrets managed securely via Vault
✅ GitOps delivery using ArgoCD
✅ Multi-layer monitoring (Prometheus, Grafana, Azure Monitor)
✅ Security scanning with Snyk

👉 Next (Optional): Build Jenkins pipelines to automate redeployments.
